// Not sure what they are for.
const WEIRD_TYPES = new Set(['Bool', 'X', 'Type']);

module.exports = ({ types, constructors, functions }) => {
  function groupByKey(collection, key) {
    return collection.reduce((byKey, member) => {
      const keyValue = member[key] || '_';

      if (!byKey[keyValue]) {
        byKey[keyValue] = [member];
      } else {
        byKey[keyValue].push(member);
      }

      return byKey;
    }, {});
  }

  function renderMtpConstructors(constructors, indent) {
    return constructors.map(({ namespace, name, argsConfig }) => `
      interface ${namespace ? `${namespace}_` : ''}${lowerCase(name)} extends GramJsInstance {
${indent}  ${Object.keys(argsConfig)
      .map((argName) => `
        ${renderArg(argName, argsConfig[argName])};
      `.trim())
      .join(`\n${indent}  `)}
${indent}}
    `.trim())
      .join(`\n${indent}`);
  }

  function renderMtpTypes(types, indent) {
    return types.map(({ namespace, name, constructors }) => `
      ${!constructors.length ? '// ' : ''}type ${namespace ? `${namespace}_` : ''}${name} = ${constructors.map(renderMtpCtorName)
      .join(' | ')};
    `.trim())
      .join(`\n${indent}`);
  }

  function renderMtpMethods(functions, indent) {
    return functions.map(({ namespace, name, argsConfig }) => `
      interface ${namespace ? `${namespace}_` : ''}${lowerCase(name)} extends GramJsInstance {
${indent}  ${Object.keys(argsConfig)
      .map((argName) => `
        ${renderArg(argName, argsConfig[argName])};
      `.trim())
      .join(`\n${indent}  `)}
${indent}}
    `.trim())
      .join(`\n${indent}`);
  }

  function renderGramJsConstructors(constructors, indent) {
    return constructors.map(({ namespace, name }) => `
      ${name}: TlConstructor<ToArgs<MTProto.${namespace ? `${namespace}_` : ''}${lowerCase(name)}>>
    `.trim())
      .join(`\n${indent}`);
  }

  function renderGramJsRequests(requests, indent) {
    return requests.map(({ namespace, name, result }) => `
      ${name}: TlRequest<
${indent}  Partial<MTProto.${namespace ? `${namespace}_` : ''}${lowerCase(name)}>,
${indent}  MTProto.${renderRequestResult(result)}
${indent}>`.trim())
      .join(`\n${indent}`);
  }

  function renderRequestResult(result) {
    const vectorMatch = result.match(/[Vv]ector<([\w\d.]+)>/);
    const isVector = Boolean(vectorMatch);
    const scalarValue = isVector ? vectorMatch[1] : result;
    const isTlType = Boolean(scalarValue.match(/^[A-Z]/)) || scalarValue.includes('.');

    return renderValueType(scalarValue, isVector, isTlType);
  }

  function renderArg(argName, argConfig, forceOptional) {
    const {
      isVector, isFlag, skipConstructorId, type
    } = argConfig;

    const valueType = renderValueType(type, isVector, !skipConstructorId);

    return `${argName === 'flags' ? '// ' : ''}${argName}${isFlag || forceOptional ? '?' : ''}: ${valueType}`;
  }

  function renderValueType(type, isVector, isTlType) {
    if (WEIRD_TYPES.has(type)) {
      return type;
    }

    let resType;

    if (typeof type === 'string' && isTlType) {
      resType = renderMtpTypeName(type);
    } else {
      resType = type;
    }

    if (isVector) {
      resType = `${resType}[]`;
    }

    return resType;
  }

  function renderMtpCtorName(fullName) {
    let [namespace, name] = fullName.includes('.') ? fullName.split('.') : [undefined, fullName];

    return `${namespace ? `${namespace}_` : ''}${lowerCase(name)}`;
  }

  function renderMtpTypeName(fullName) {
    let [namespace, name] = fullName.includes('.') ? fullName.split('.') : [undefined, fullName];

    return `${namespace ? `${namespace}_` : ''}${name}`;
  }

  function lowerCase(str) {
    return `${str[0].toLowerCase()}${str.slice(1)}`;
  }

  const constructorsByNs = groupByKey(constructors, 'namespace');
  const requestsByNs = groupByKey(functions, 'namespace');

  // language=TypeScript
  return `
// This file is autogenerated. All changes will be overwritten.

import { BigInteger } from 'big-integer';

interface GramJsInstance {
  CONSTRUCTOR_ID: number;
  SUBCLASS_OF_ID: number;

  getBytes(): Buffer;
}

type ToArgs<T> = Omit<T, 'CONSTRUCTOR_ID' | 'SUBCLASS_OF_ID' | 'getBytes'>

export namespace MTProto {

  type AnyClass = new (...args: any[]) => any;
  type AnyLiteral = Record<string, any>;
  type Buffer = Uint8Array;

  type Reader = any; // To be defined.
  type Client = any; // To be defined.
  type Utils = any; // To be defined.

  type X = unknown; // TODO Verify this.
  type Type = unknown; // TODO Verify this.
  type Bool = boolean;
  type int128 = number;
  type int256 = number;
  type long = number[] | string | BigInteger;
  type bytes = string | Uint8Array;

  ${renderMtpConstructors(constructors, '  ')}

  ${renderMtpTypes(types, '  ')}

  ${renderMtpMethods(functions, '  ')}

}

// For some reason when \`interface TlRequest extends TlConstructor\`,
// the \`InstanceType<TlRequest>\` refers to the parent class (\`TlConstructor\`) instance.
interface TlCommon<Args extends AnyLiteral> {
  serializeBytes(data: Buffer | string): Buffer;

  serializeDate(date: Date | number): Buffer;

  fromReader(reader: Reader): GramJsInstance & Args;
}

interface TlConstructor<Args> extends TlCommon<Args> {
  new(args: Args): GramJsInstance & Args;
}

interface TlRequest<Args, Response> extends TlCommon<Args> {
  new(args: Args): GramJsInstance & Args & {
    className: string;
    classType: 'request';

    __response: Response;
  };

  className: string;
  classType: 'request';

  readResult(reader: Reader): Buffer;

  resolve(client: Client, utils: Utils): Promise<void>;
}

interface Constructors {
  ${renderGramJsConstructors(constructorsByNs._, '  ')}
  ${Object.keys(constructorsByNs)
    .map(namespace => namespace !== '_' ? `
  ${namespace}: {
    ${renderGramJsConstructors(constructorsByNs[namespace], '    ')}
  }` : '')
    .join('\n')}
}

interface Requests {
  ${renderGramJsRequests(requestsByNs._, '  ')}
  ${Object.keys(requestsByNs)
    .map(namespace => namespace !== '_' ? `
  ${namespace}: {
    ${renderGramJsRequests(requestsByNs[namespace], '    ')}
  }` : '')
    .join('\n')}
}

type ValuesOf<T> = T[keyof T];

export namespace GramJsApi {
  type AnyRequest = ${requestsByNs._.map(({ name }) => `Requests['${name}']`)
    .join(' | ')} |
    ${Object.keys(requestsByNs)
    .filter(ns => ns !== '_')
    .map(ns => `ValuesOf<Requests['${ns}']>`)
    .join(' | ')};
}

declare const gramJsApi: {
  constructors: Constructors;
  requests: Requests;
};

export default gramJsApi;
`;
};
